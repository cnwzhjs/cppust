use std::io::Write;

use crate::gen::names::IdentName;

use super::error::{Result, Error};
use syn::{Fields, ItemEnum};

pub fn tag(f: &mut dyn Write, item: &ItemEnum) -> Result<()> {
    const INDENT: &'static str = "    ";

    writeln!(f, "{}enum class _Tag {{", INDENT)?;
    for varient in item.variants.iter() {
        let varient_name: IdentName = (&varient.ident).into();
        writeln!(f, "{}    {},", INDENT, varient_name.to_enum_variant_name())?;
    }
    writeln!(f, "{}}};", INDENT)?;
    writeln!(f)?;

    Ok(())
}

pub fn union(f: &mut dyn Write, item: &ItemEnum) -> Result<()> {
    const INDENT: &'static str = "    ";

    // write union alignment
    writeln!(
        f,
        "{}static constexpr const size_t _kUnionAlign = ::cppust::utils::align_of_union_value<",
        INDENT
    )?;

    writeln!(f, "{}    ::cppust::u8", INDENT)?;

    for variant in item.variants.iter() {
        match variant.fields {
            Fields::Unit => continue,
            _ => writeln!(
                f,
                "{}    , {}",
                INDENT,
                super::types::fields_to_cpp_type(&variant.fields)?
            )?,
        }
    }

    writeln!(f, "{}>();", INDENT)?;
    writeln!(f)?;

    // write union definition
    writeln!(f, "{}union alignas(_kUnionAlign) _Union {{", INDENT)?;

    for variant in item.variants.iter() {
        let variant_name: IdentName = (&variant.ident).into();
        match variant.fields {
            Fields::Unit => continue,
            _ => {}
        };
        writeln!(
            f,
            "{}    {} {}_val;",
            INDENT,
            super::types::fields_to_cpp_type(&variant.fields)?,
            variant_name.to_public_member_name()
        )?;
    }

    writeln!(f, "{}    inline _Union() {{}}", INDENT)?;
    writeln!(f, "{}    inline ~_Union() {{}}", INDENT)?;
    writeln!(f, "{}}};", INDENT)?;
    writeln!(f)?;

    Ok(())
}

pub fn write(f: &mut dyn Write, item: &ItemEnum, namespace: &Vec<String>) -> Result<()> {
    let enum_ident_name: IdentName = (&item.ident).into();

    writeln!(
        f,
        "// THIS FILE IS GENERATED BY cppust-gen, YOU CAN CHANGE THIS FILE ON YOUR OWN"
    )?;
    writeln!(f)?;

    writeln!(f, "#pragma once")?;
    writeln!(f)?;

    writeln!(f, "#include <cppust/cppust.hpp>")?;
    writeln!(f)?;
    writeln!(f, "#include <iostream>")?;
    writeln!(f)?;

    if !namespace.is_empty() {
        writeln!(
            f,
            "{}",
            namespace
                .iter()
                .map(|ns| format!("namespace {} {{", ns))
                .collect::<Vec<String>>()
                .join(" ")
        )?;
        writeln!(f)?;
    }

    writeln!(f, "class {} {{", enum_ident_name.to_class_name())?;
    writeln!(f, "#include \"{}.inc.hpp\"", enum_ident_name.to_file_name())?;
    writeln!(f)?;
    writeln!(f, "public:")?;
    writeln!(f, "    // WRITE YOUR OWN CODE HERE")?;
    writeln!(f, "}};")?;

    if !namespace.is_empty() {
        writeln!(f)?;
        writeln!(
            f,
            "{}",
            namespace
                .iter()
                .map(|_| "}".to_owned())
                .collect::<Vec<String>>()
                .join(" ")
        )?;
    }

    writeln!(f)?;
    writeln!(f, "#include \"{}.fmt.hpp\"", enum_ident_name.to_file_name())?;

    Ok(())
}

pub fn write_inc(f: &mut dyn Write, item: &ItemEnum) -> Result<()> {
    let enum_ident_name: IdentName = (&item.ident).into();

    writeln!(
        f,
        "// THIS FILE IS GENERATED AND MANAGED BY cppust-gen, DO NOT CHANGE"
    )?;
    writeln!(
        f,
        "// PLEASE CHANGE {}.hpp INSTEAD",
        enum_ident_name.to_file_name()
    )?;
    writeln!(f)?;

    writeln!(f, "private: // type definition")?;
    tag(f, item)?;
    union(f, item)?;
    writeln!(f)?;

    writeln!(f, "public: // ctors, dtors, opeartors")?;
    writeln!(f, "    {0}(const {0}&);", enum_ident_name.to_class_name())?;
    writeln!(f, "    {0}({0}&&);", enum_ident_name.to_class_name())?;
    writeln!(f, "    ~{}();", enum_ident_name.to_class_name())?;
    writeln!(f)?;
    writeln!(
        f,
        "    {0}& operator=(const {0}&);",
        enum_ident_name.to_class_name()
    )?;
    writeln!(
        f,
        "    {0}& operator=({0}&&);",
        enum_ident_name.to_class_name()
    )?;
    writeln!(
        f,
        "    bool operator==(const {0}&) const;",
        enum_ident_name.to_class_name()
    )?;
    writeln!(
        f,
        "    bool operator!=(const {0}&) const;",
        enum_ident_name.to_class_name()
    )?;
    // writeln!(
    //     f,
    //     "    friend std::ostream& ::operator<<(std::ostream& os, const {}&);  // Display",
    //     enum_ident_name.to_class_name()
    // )?;
    writeln!(
        f,
        "    template<typename> friend struct ::cppust::debug;  // Debug",
    )?;
    writeln!(f)?;

    writeln!(f, "public: // enum constructors")?;
    for variant in item.variants.iter() {
        let variant_name: IdentName = (&variant.ident).into();

        match variant.fields {
            Fields::Unit => {
                writeln!(
                    f,
                    "    static {0} {1}();",
                    enum_ident_name.to_class_name(),
                    variant_name.to_class_name()
                )?;
            },
            Fields::Unnamed(_) => {
                write!(
                    f,
                    "    static {0} {1}(",
                    enum_ident_name.to_class_name(),
                    variant_name.to_class_name(),
                )?;
                for (i, field) in variant.fields.iter().enumerate() {
                    if i != 0 {
                        write!(f, ", ")?;
                    }
                    write!(f, "const {}&", super::types::type_to_cpp_type(&field.ty)?)?;
                }
                writeln!(f, ");")?;
            },
            _ => return Err(Error::UnknownFieldsType(variant.fields.clone())),
        }
    }
    writeln!(f)?;

    writeln!(f, "public: // value accessors")?;
    for variant in item.variants.iter() {
        let variant_name: IdentName = (&variant.ident).into();

        writeln!(
            f,
            "    bool is_{}() const;",
            variant_name.to_public_member_name()
        )?;
        writeln!(f)?;

        match variant.fields {
            Fields::Unit => continue,
            _ => {
                let cpp_type_name = super::types::fields_to_cpp_type(&variant.fields)?;
                writeln!(
                    f,
                    "    const {1}& {0}_ref_uncheck() const;",
                    variant_name.to_public_member_name(),
                    cpp_type_name
                )?;
                writeln!(
                    f,
                    "    {1}& {0}_ref_uncheck();",
                    variant_name.to_public_member_name(),
                    cpp_type_name
                )?;
                writeln!(f)?;
                writeln!(
                    f,
                    "    const {1}& {0}_ref() const;",
                    variant_name.to_public_member_name(),
                    cpp_type_name
                )?;
                writeln!(
                    f,
                    "    {1}& {0}_ref();",
                    variant_name.to_public_member_name(),
                    cpp_type_name
                )?;
                writeln!(f)?;
                writeln!(
                    f,
                    "    const {1}* {0}_ptr() const;",
                    variant_name.to_public_member_name(),
                    cpp_type_name
                )?;
                writeln!(
                    f,
                    "    {1}* {0}_ptr();",
                    variant_name.to_public_member_name(),
                    cpp_type_name
                )?;
                writeln!(f)?;
            }
        }
    }

    writeln!(f, "private:")?;
    writeln!(f, "    _Union union_;")?;
    writeln!(f, "    _Tag tag_;")?;
    writeln!(f)?;
    writeln!(f, "    {}(_Tag);", enum_ident_name.to_class_name())?;
    writeln!(
        f,
        "    {}(_Tag, const _Union&);",
        enum_ident_name.to_class_name()
    )?;
    writeln!(
        f,
        "    {}(_Tag, _Union&&);",
        enum_ident_name.to_class_name()
    )?;
    writeln!(f)?;
    writeln!(f, "    void tagged_init_(_Tag, const _Union&);")?;
    writeln!(f, "    void tagged_init_(_Tag, _Union&&);")?;
    writeln!(f, "    void deinit_union_();")?;

    Ok(())
}

pub fn write_fmt(f: &mut dyn Write, item: &ItemEnum, namespace: &Vec<String>) -> Result<()> {
    let enum_ident_name: IdentName = (&item.ident).into();
    let namespace = namespace.iter().map(|ns| format!("{}::", ns)).collect::<Vec<_>>().join("");

    writeln!(
        f,
        "// THIS FILE IS GENERATED AND MANAGED BY cppust-gen, DO NOT CHANGE"
    )?;
    writeln!(
        f,
        "// PLEASE CHANGE {}.hpp INSTEAD",
        enum_ident_name.to_file_name()
    )?;
    writeln!(f)?;

    // writeln!(
    //     f,
    //     "std::ostream& operator<<(std::ostream& os, const {}{}& self); // Display",
    //     &namespace,
    //     enum_ident_name.to_class_name()
    // )?;
    // writeln!(f)?;
    writeln!(f, "namespace cppust {{")?;
    writeln!(
        f,
        "    template <> struct debug<{}{}> {{ // Debug",
        &namespace,
        enum_ident_name.to_class_name()
    )?;
    writeln!(
        f,
        "        static std::ostream& fmt(const {}{}& self, std::ostream& os) {{",
        &namespace,
        enum_ident_name.to_class_name()
    )?;
    writeln!(f, "            switch (self.tag_) {{")?;
    for variant in item.variants.iter() {
        let variant_ident_name: IdentName = (&variant.ident).into();

        writeln!(
            f,
            "            case {}{}::_Tag::{}:",
            &namespace,
            enum_ident_name.to_class_name(),
            variant_ident_name.to_enum_variant_name()
        )?;
        if let Fields::Unit = &variant.fields {
            writeln!(
                f,
                "                return os<<\"{}\";",
                variant_ident_name.to_enum_variant_name()
            )?;
        } else {
            writeln!(
                f,
                "                return os<<\"{}(\"<<::cppust::as_debug(self.union_.{}_val)<<\")\";",
                variant_ident_name.to_enum_variant_name(),
                variant_ident_name.to_public_member_name()
            )?;
        }
    }
    writeln!(f, "            default:")?;
    writeln!(f, "                return os<<\"<?>(\"<<int(self.tag_)<<\")\";")?;
    writeln!(f, "            }}")?;
    writeln!(f, "        }}")?;
    writeln!(f, "    }};")?;
    writeln!(f, "}}")?;

    Ok(())
}
